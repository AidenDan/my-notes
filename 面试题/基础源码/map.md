# Map

### HashMap的结构

HashMap是由一个Node的数组table作为哈希表，和Node链表/红黑树组成。



### 为什么扩容负载因子是0.75

因为每个元素的下标是基于对整个数组长度取余组成的，所以不能让数组占满后再扩容，否则会造成Node结构失去平衡，增加了时间复杂度。

所以扩容应当在一个尽可能让哈系表元素充分，又不至于影响性能的负载情况下，这个0.75这个数据来自与于实验。



### HashMap添加元素的逻辑

1. put方法接收一个key，value数据
2. 判断table为空，resize初始化table
3. hash方法重新计算key的hash
4. 根据通过(h-1)&hash得到数组的下标对应元素
5. 若对应元素为空则直接newNode然后赋值，否则
6. 从头遍历链表，调用equal方法进行比对，若equal成功则覆盖，不成功在链表尾部插入。（or 红黑树）
7. 检查是否需要扩容（eg：12不用，13就需要）



### HashMap何时扩容与它的原理及1.8的扩容优化

initicapacity = (存储元素个数 / loader factor) + 1

HashMap会在插入数据之后，判断元素个数是否大于等于0.75×数组长度的threshold，则对原数组长度进行2倍resize处理

扩容过程：新数组？？

会对每个元素的hash重新对新长度取余计算下标。1.8版本会将新取余的结果为0的不做移动，然后对其他的结果则将它们的新的取余结果再加上老长度，得到新的下标位置。



### 为什么扩容要是2倍

因为2倍的话，因为扩容而移动的元素会较少，老数据对新容量取余为0的都不需要移动,其他移动一个老数组长度即可。

### hash()的作用

hash()的目的是让对象的hashCode可以充分的和数组长度进行取余运算。

因为取余求下标的操作运算实际是hashCode & (数组长度 - 1)，以默认的hashCode数组长度16为例，所有的hashCode对16-1=15即000...000111取余，实际上总是后三位在和hashCode进行运算，因为往往hash表的长度并不会太长，所以hashCode的高16位往往是没什么用的，这样发生冲突的概率会非常高。

为了解决这个问题，hash()截取（位移方式）原始hashCode的高16位对低16位进行^异或操作，让高16位也参与到运算中。



### 为什么用^而不用&和|

因为&偏0,|偏1,^相对中立。



### 为什么1.7会出现死循环，1.8改了什么

1.7会出死循环主要是源于其扩容前后，链表的顺序会被颠倒而因并发问题发生无限循环。

1.7扩容会从链表头的每个元素都重新计算位置，也就是从头获取数据再插到目标位置的链表头，这样就造成了链表的颠倒。

在并发的情况下，有可能造成本身链表是： b,c;b->next是c，而线程2在扩容后改成了c，b，然后又把c->next设置成了b，这样再去获取元素时，就造成了死循环。

### 初始容量应当如何设置

initicapacity = (存储元素个数 / loader factor) + 1

如果存10个元素，那你应当先算出容量为 （10/0.75）+1 = 14,

然后应当获取14向上的第一个比14大的2的幂的数，即16.



### hashMap什么情况下转红黑树

在链表长度（达到）8，且总数组长度达到64。



### 会不会出现数组仅占用了一个元素而发生扩容的情况

理论上会。扩容的依据为总元素个数。但是倒是不至于发生太偏的问题。


